enum PickupConstants
{
	//Armor Per Difficulty
	ArmorCapGreen =				100,
	ArmorCapBlue =				200,
	ArmorCapGreenNormal =		100,	//UV
	ArmorCapGreenNightmare =	100,		//Nightmare
	ArmorCapGreenUltra =		100,		//Ultra Nightmare
	ArmorCapBlueNormal =		200,
	ArmorCapBlueNightmare =		200,
	ArmorCapBlueUltra =			200,
	
	ArmorGreenNormal =		100,	//UV
	ArmorGreenNightmare =	75,		//Nightmare
	ArmorGreenUltra =		50,		//Ultra Nightmare
	ArmorBlueNormal =		200,
	ArmorBlueNightmare =	150,
	ArmorBlueUltra =		100,
	

	PinataLifetime = 			175 + DelayVacuum, 
	PinataLifetimeLong = 		700 + DelayVacuum, 
	PinataLifetimeSuperLong = 	4200 + DelayVacuum, //2min
	RadiusPull = 				192,
	DelayVacuum =				20,
	PSpeed = 					24,
	VelFlags =					CVF_RELATIVE|CVF_REPLACE,
};

//=======================================================================
//=======================================================================
// Health
//=======================================================================
//=======================================================================

Class D4Stimpack : Health replaces Stimpack
{	
	Default 
	{
		Inventory.PickupMessage "Small health";
		Inventory.Amount 10;
		Inventory.PickUpSound "Doom4/Pickups/Health";
		DistanceCheck "user_MaxDrawDistance";
		Scale 0.5;
	}
	States
	{
	Spawn:
		D4HL A -1 NODELAY A_SetAngle(random(0,359));
		Stop;
	}
}

Class D4Medikit : Health replaces Medikit
{	
	Default 
	{
		Inventory.PickupMessage "Big health";
		Inventory.PickUpSound "Doom4/Pickups/HealthLarge";
		Inventory.Amount 30;
		Scale 0.5;
		DistanceCheck "user_MaxDrawDistance";
	}
	States
	{
	Spawn:
		D4HL B -1 NODELAY A_SetAngle(random(0,359));
		Stop;
	}
}

Class D4HealthBonus : HealthBonus replaces HealthBonus
{	
	Default 
	{
		Inventory.PickUpSound "Doom4/Pickups/HealthBonus";
		Scale 0.55;
		Inventory.Amount 3;
		DistanceCheck "user_MaxDrawDistance";
	}
	States
	{
	Spawn:
		D4HL C -1 NODELAY A_SetAngle(random(0,359));
		Stop;
	}
}

// This should never be spawned.
Class D4HealthBonusUpgraded : D4HealthBonus
{
	Default
	{
		+INVENTORY.IGNORESKILL
		Inventory.MaxAmount 300;
	}
	States
	{
	Spawn:
		TNT1 A 0;
		Stop;
	}
}

//=======================================================================
//=======================================================================
// Armor
//=======================================================================
//=======================================================================

Class ArmorStripper : CustomInventory
{
	Default 
	{
		+INVENTORY.ALWAYSPICKUP
	}
	States
	{
	Pickup:
		TNT1 A 0
		{
			A_SetInventory("Armor",0);
			A_SetInventory("ArmorBonus",0);
			A_SetInventory("BasicArmor",0);
			A_SetInventory("BasicArmorBonus",0);
			A_SetInventory("BasicArmorPickup",0);
			A_SetInventory("D4ArmorBonus",0);
			A_SetInventory("D4GreenArmor",0);
			A_SetInventory("D4BlueArmor",0);
			A_SetInventory("D4BasicArmorBonus",0);
			A_SetInventory("D4ArmorBonus",0);
			A_SetInventory("D4ArmorPickup",0);
			A_SetInventory("D4BlueArmorMegasphere",0);
			return true;
		}
		Stop;
	}
}

Class D4ArmorBasePickup : CustomInventory
{
	int BaseLimit;		// The soft limit without upgrades.
	int MaxSaveAmount;	// The hard limit.
	int SavePercent;
	int SaveAmount;
	int MaxAbsorb;
	int MaxFullAbsorb;
	bool IgnoreSkill;
	
	property BaseLimit: BaseLimit;
	property SavePercent: SavePercent;
	property SaveAmount: SaveAmount;
	property MaxSaveAmount: MaxSaveAmount;
	property MaxAbsorb: MaxAbsorb;
	property MaxFullAbsorb: MaxFullAbsorb;
	property IgnoreSkill: IgnoreSkill;
	Default
	{
		D4ArmorBasePickup.SavePercent 100;
		D4ArmorBasePickup.SaveAmount 3;
		D4ArmorBasePickup.BaseLimit 200;
		D4ArmorBasePickup.MaxSaveAmount 200;
		D4ArmorBasePickup.MaxAbsorb 200;
		D4ArmorBasePickup.MaxFullAbsorb 200;
		D4ArmorBasePickup.IgnoreSkill false;
		Inventory.PickupMessage "";
		Inventory.PickUpSound "Doom4/Pickups/ArmorShard";
		DistanceCheck "user_MaxDrawDistance";
		Scale 0.5;
	}
	States
	{
	Spawn:
		D4AR C -1 NODELAY A_SetAngle(random(0,359));
		Stop;
	Pickup:
		TNT1 A 0
		{ // See top of file for armor cap definitions.
			
			let inv = BasicArmor(FindInventory("BasicArmor"));
			
			if (!inv)
			{
				if (A_GiveInventory("ArmorStripper",1))
				{
					A_GiveInventory("D4GreenArmorGiver",1);
				}
				return true;
			}
			int Cap = Min(invoker.BaseLimit + CountInv("D4ArmorCapRaiser"), invoker.MaxSaveAmount);
			inv.SavePercent = invoker.SavePercent;
			if (inv.Amount < Cap)
			{
				double SkillFactor = 1.0;
				if (!invoker.IgnoreSkill)
				{
						 if (skill == 3) SkillFactor = 0.75;
					else if (skill >= 4) SkillFactor = 0.5;
				}
				inv.Amount = Min(inv.Amount + int((invoker.SaveAmount * Max(1,invoker.Amount)) * SkillFactor), Cap);
				invoker.Amount = 1;
				inv.ArmorType = inv.GetClassName();
				inv.MaxFullAbsorb = invoker.MaxFullAbsorb;
				inv.MaxAbsorb = invoker.MaxAbsorb;
				return true;
			}
			return false;
		}
		Stop;
	}
}

Class D4ArmorPickup : BasicArmorPickup replaces BasicArmorPickup
{	
	Default 
	{
		DistanceCheck "user_MaxDrawDistance";
		Armor.SavePercent 100;
		Armor.MaxAbsorb 200;
		Armor.MaxFullAbsorb 200;
	}
}

Class D4BasicArmorBonus : BasicArmorBonus replaces BasicArmorBonus
{
	Default 
	{
		DistanceCheck "user_MaxDrawDistance";
		Armor.SavePercent 100;
		Armor.MaxAbsorb 200;
		Armor.MaxFullAbsorb 200;
	}
}

Class D4ArmorBonus : ArmorBonus
{
	Default
	{
		Armor.SavePercent 100;
		Armor.MaxAbsorb 200;
		Armor.MaxFullAbsorb 200;
		Armor.SaveAmount 3;
		DistanceCheck "user_MaxDrawDistance";
		Inventory.PickUpSound "Doom4/Pickups/ArmorShard";
		Scale 0.55;
		+ALLOWPAIN
	}
	States
	{
	Spawn:
		D4AR B -1 NODELAY A_SetAngle(random(0,359));
		Stop;
	}
}

Class D4ArmorBonusPickup : D4ArmorBasePickup replaces ArmorBonus
{
	Default 
	{
		D4ArmorBasePickup.SavePercent 100;
		D4ArmorBasePickup.SaveAmount 3;
		D4ArmorBasePickup.BaseLimit 200;
		D4ArmorBasePickup.MaxSaveAmount 200;
		D4ArmorBasePickup.MaxAbsorb 200;
		D4ArmorBasePickup.MaxFullAbsorb 200;
		DistanceCheck "user_MaxDrawDistance";
		Inventory.PickUpSound "Doom4/Pickups/ArmorShard";
		Scale 0.55;
		+INVENTORY.ALWAYSPICKUP
	}
	States
	{
	Spawn:
		D4AR B -1 NODELAY A_SetAngle(random(0,359));
		Stop;
	}
}

Class D4GreenArmorGiver : ArmorBonus
{
	Default 
	{
		+INVENTORY.ALWAYSPICKUP
		Armor.SavePercent 100;
		Armor.SaveAmount 100;
		Armor.MaxAbsorb 200;
		Armor.MaxFullAbsorb 200;
		
	}
}

Class D4GreenArmor100 : D4GreenArmorGiver { Default { +INVENTORY.IGNORESKILL }}

Class D4BlueArmorGiver : ArmorBonus
{
	Default 
	{
		+INVENTORY.ALWAYSPICKUP
		Armor.SavePercent 100;
		Armor.SaveAmount 200;
		Armor.MaxAbsorb 200;
		Armor.MaxFullAbsorb 200;
	}
}
Class D4BlueArmor200 : D4BlueArmorGiver
{
	Default { +INVENTORY.IGNORESKILL }
}

// Allow me to explain wtf is going on here...
// When it comes to syphon armor and the regular armor pickup, the two just
// did not get along well. So I came up with a system utilizing CustomInventory
// to do the measuring instead, and voila! Problem solved. It can now be picked
// up at any time while wearing any kind of armor, provided the armor is lower
// than the specified amount.

Class ArmorCount : Inventory { Default { Inventory.MaxAmount 200;	Inventory.InterhubAmount 0; }}

Class ArmorSinglePoint : D4ArmorBonus
{
	Default 
	{
		+INVENTORY.ALWAYSPICKUP
		+INVENTORY.IGNORESKILL
		Armor.SaveAmount 1;
	}
}

Class D4GreenArmor : D4ArmorBasePickup replaces GreenArmor
{
	Default 
	{
		D4ArmorBasePickup.SavePercent 100;
		D4ArmorBasePickup.SaveAmount ArmorCapGreen;
		D4ArmorBasePickup.BaseLimit 100;
		D4ArmorBasePickup.MaxSaveAmount 200;
		D4ArmorBasePickup.MaxAbsorb 200;
		D4ArmorBasePickup.MaxFullAbsorb 200;
		Inventory.PickUpSound "Doom4/Pickups/ArmorMed";
		Inventory.PickUpMessage "Medium Armor Chunk";
		DistanceCheck "user_MaxDrawDistance";
		Scale 0.5;
	}
	States
	{
	Spawn:
		D4AR C -1 NODELAY A_SetAngle(random(0,359));
		Stop;
	}
}

Class D4BlueArmor : D4ArmorBasePickup replaces BlueArmor
{
	Default
	{
		D4ArmorBasePickup.SavePercent 100;
		D4ArmorBasePickup.SaveAmount ArmorCapBlue;
		D4ArmorBasePickup.BaseLimit 200;
		D4ArmorBasePickup.MaxSaveAmount 200;
		D4ArmorBasePickup.MaxAbsorb 200;
		D4ArmorBasePickup.MaxFullAbsorb 200;
		Inventory.PickUpSound "Doom4/Pickups/Armor";
		Inventory.PickUpMessage "Full Armor Casing";
		DistanceCheck "user_MaxDrawDistance";
		Scale 0.75;
	}
	States
	{
	Spawn:
		D4AR A -1 NODELAY A_SetAngle(random(0,359));
		Stop;
	}
}


//=======================================================================
//=======================================================================
// Backpack
//=======================================================================
//=======================================================================
Class D4Backpack : BackpackItem replaces Backpack 
{
	int user_rangle;
	Default 
	{
		Scale 0.7;
		Inventory.PickupMessage "Picked up a backpack";
		Height 26;
	}
	States
	{
	Spawn:
		BPAK A -1 NoDelay
		{
			user_rangle = random(0,359);
			
			A_SetAngle(user_rangle);
			
			if (!CountInv("FragGrenadePickup",Player1))
			{
				A_SpawnItemEx("FragGrenadeWorld",0,0,0,0,0,0,user_rangle,SXF_NOCHECKPOSITION|SXF_ABSOLUTEANGLE);
				
			}
			else if (!CountInv("HoloGrenadePickup",Player1))
			{
				A_SpawnItemEx("HoloGrenadeWorld",0,0,0,0,0,0,user_rangle,SXF_NOCHECKPOSITION|SXF_ABSOLUTEANGLE);
				
			}
			else if (!CountInv("SyphonGrenadePickup",Player1))
			{
				A_SpawnItemEx("SyphonGrenadeWorld",0,0,0,0,0,0,user_rangle,SXF_NOCHECKPOSITION|SXF_ABSOLUTEANGLE);
			}
		}
		Stop;
	}
}

//==============================================================================
//==============================================================================
// Upgrades Made Manifest
//==============================================================================
//==============================================================================

Class D4UpgradePickupSpawner : Actor
{
	Array<String> items;
	override void PostBeginPlay()
	{
		Actor temp = tracer;
		A_TransferPointer(Player1,DefPtr,DefPtr,TracerPtr,4);
		let plr = PlayerPawn(tracer);
		tracer = temp;
		
		int filled = 0;
		items.Clear();
		
		
		if (plr)
		{
			// filled is used only for the soviet upgrade.
			if (plr.CountInv("D4Pistol"))
			{
				if (!plr.CountInv("PistolUpgradeAutomatic") ||
					!plr.CountInv("PistolUpgradeAltDamage") ||
					!plr.CountInv("PistolUpgradeAltCharge") ||
					!plr.CountInv("PistolUpgradeDamage") ||
					!plr.CountInv("PistolUpgradeLance"))
					items.Push("PistolUpgradePickup");				else	filled++;
			}
			if (plr.CountInv("D4Shotgun"))
			{
				if (!plr.CountInv("ShotgunMod1") ||	!plr.CountInv("ShotgunMod2"))
					items.Push("ShotgunUpgradePickup");				else	filled++;
			}
			if (plr.CountInv("D4SuperShotgun"))
			{
				if (!plr.CountInv("SSGUpgrade1") ||	!plr.CountInv("SSGUpgrade2") ||
					!plr.CountInv("SSGUpgrade3") ||	!plr.CountInv("SSGUpgrade4"))
					items.Push("SuperShotgunUpgradePickup");		else	filled++;
			}
			if (plr.CountInv("D4AssaultRifle"))
			{
				if (!plr.CountInv("AssaultRifleMod1") || !plr.CountInv("AssaultRifleMod2"))
					items.Push("AssaultRifleUpgradePickup");		else	filled++;
			}
			if (plr.CountInv("D4Chaingun"))
			{
				if (!plr.CountInv("ChaingunMod1") || !plr.CountInv("ChaingunMod2"))
					items.Push("ChaingunUpgradePickup");			else	filled++;
			}
			if (plr.CountInv("D4RocketLauncher"))
			{
				if (!plr.CountInv("RocketLauncherMod1") ||!plr.CountInv("RocketLauncherMod2"))
					items.Push("RocketLauncherUpgradePickup");		else	filled++;
			}
			if (plr.CountInv("D4PlasmaRifle"))
			{
				if (!plr.CountInv("PlasmaRifleMod1") ||	!plr.CountInv("PlasmaRifleMod2"))
					items.Push("PlasmaRifleUpgradePickup");			else	filled++;
			}
			if (plr.CountInv("D4GaussCannon"))
			{
				if (!plr.CountInv("GaussCannonMod1") ||	!plr.CountInv("GaussCannonMod2"))
					items.Push("GaussCannonUpgradePickup");			else	filled++;
			}
			if (plr.CountInv("D4BFG"))
			{
				if (!plr.CountInv("BFGUpgrade1") ||	!plr.CountInv("BFGUpgrade2") ||
					!plr.CountInv("BFGUpgrade3") ||	!plr.CountInv("BFGUpgrade4"))
					items.Push("BFGUpgradePickup");					else	filled++;
			}
			if (plr.CountInv("D4Repeater"))
			{
				if (!plr.CountInv("RepeaterUpgradePiercing") ||
					!plr.CountInv("RepeaterUpgradeDamage") ||
					!plr.CountInv("RepeaterUpgradeAltDamage") ||
					!plr.CountInv("RepeaterUpgradeAltAmmo"))
					items.Push("RepeaterUpgradePickup");
			}
			if (plr.CountInv("D4LightningGun"))
			{
				if (!plr.CountInv("LGUpgradeAmmo") || !plr.CountInv("LGUpgradeRange") ||
					!plr.CountInv("LGUpgradeDamage") ||	!plr.CountInv("LGUpgradeAltFire"))
					items.Push("LightningGunUpgradePickup");
			}
			
			if (plr.CountInv("D4StaticRifle"))
			{
				if (!plr.CountInv("StaticUpgrade1") ||
					!plr.CountInv("StaticUpgrade2") ||
					!plr.CountInv("StaticUpgrade3") ||
					!plr.CountInv("StaticUpgrade4"))
					items.Push("StaticRifleUpgradePickup");
			}
			
			if (plr.CountInv("D4VortexRifle"))
			{
				if (!plr.CountInv("VortexUpgradeDamage") ||
					!plr.CountInv("VortexUpgradeAmmo") ||
					!plr.CountInv("VortexUpgradeAltSpeed") ||
					!plr.CountInv("VortexUpgradeAltPierce"))
					items.Push("VortexRifleUpgradePickup");
			}
			
			if (plr.CountInv("D4CarrionCannon"))
			{
				if (!plr.CountInv("CarrionUpgradeAmmo") ||
					!plr.CountInv("CarrionUpgradeStun") ||
					!plr.CountInv("CarrionUpgradeTime") ||
					!plr.CountInv("CarrionUpgradePickup"))
					items.Push("CarrionCannonUpgradePickup");
			}
			
			if (!plr.CountInv("D4MegachargeUpgrade1") || 
				!plr.CountInv("D4MegachargeUpgrade2") ||
				!plr.CountInv("D4DoomDollUpgrade1") || 
				!plr.CountInv("D4DoomDollUpgrade2") ||
				!plr.CountInv("D4RegenUpgrade1") ||	
				!plr.CountInv("D4RegenUpgrade2") ||
				!plr.CountInv("D4RegenUpgrade3") ||	
				!plr.CountInv("D4RegenUpgrade4") ||
				!plr.CountInv("D4PentagramUpgrade1") ||	
				!plr.CountInv("D4PentagramUpgrade2") ||
				!plr.CountInv("D4PentagramUpgrade3") ||	
				!plr.CountInv("D4PentagramUpgrade4") ||
				// !plr.CountInv("D4RuneUpgrade1") || 
				!plr.CountInv("D4RuneUpgrade2") ||
				!plr.CountInv("D4RuneUpgrade3") ||
				!plr.CountInv("D4RuneUpgrade4"))
				items.Push("D4PowerUpgradePickup");
			
		
			if (plr.CountInv("D4AirUpgrade") < 3 ||
				plr.CountInv("D4Stamina") < 100 ||
				plr.CountInv("D4ArmorCapRaiser") < 100 ||
				plr.CountInv("D4CrateUpgrade") < 3 ||
				plr.CountInv("ProtectionBonus") < 3)
					items.Push("D4SuitUpgradePickup");
		}
		else
		{
			Console.Printf("ERROR: Couldn't find player!");
			return Destroy();
		}
		
		// The weapons needed for the soviet chaingun have all been filled.
		// Spawn it in addition to whatever else will spawn as a bonus reward.
		if (filled >= 9)
		{
			let soviet = Actor(Spawn("SovietChaingunUpgradePickup",pos));
			if (soviet)	
			{
				soviet.vel = vel;
				soviet.target = target;
				soviet.master = master;
				soviet.tracer = tracer;
			}
		}		
		int size = items.Size();
		
		if (size > 0)
		{
			Class<Inventory> check = items[random(0,size - 1)];
			
			Actor ItemToSpawn = Actor(Spawn(check,pos));
			if (ItemToSpawn)
			{
				ItemToSpawn.vel = vel;
				ItemToSpawn.target = target;
				ItemToSpawn.master = master;
				ItemToSpawn.tracer = tracer;
				return Destroy();
			}
		}
		//======================================================================
		// Weapons
		//======================================================================
		return Destroy();		
	}
	
	Default
	{
		+NOINTERACTION
	}
}

//==============================================================================
// Powerups
//==============================================================================

Class D4PowerUpgradePickup : CustomInventory
{
	UpgradePinataFlier flier;
	int count;
	int ticker;
	bool Flying;
	Array<String> items;
	Default
	{
		+INVENTORY.ALWAYSPICKUP
		+BRIGHT
		Inventory.PickupMessage "Random Powerup Upgrade gives you...";
	}
	States
	{
	Spawn:
		M670 F 17 NoDelay
		{
			invoker.flier = new("UpgradePinataFlier");
			if (invoker.flier)
			{
				invoker.flier.Spawner = invoker;
				invoker.flier.NoItem = true;
			}
		}
		M671 F 17;
		"----" A 1
		{
			invoker.ticker = (invoker.ticker + 1) % 34;
			
			Name spr = (invoker.ticker < 17) ? "M670" : "M671";
				
			if (invoker.count >= DelayVacuum)
			{
				if (invoker.tracer)
				{
					invoker.count = DelayVacuum;
					PlrCheck.SetFlying(invoker, true);
					A_FaceTracer(0,0,0,0,FAF_MIDDLE);
					A_ChangeVelocity(x: cos(pitch)*PSpeed, z: -sin(pitch)*PSpeed, flags: CVF_RELATIVE|CVF_REPLACE);
					if (Distance3D(tracer) <= 32)
					{	SetOrigin(tracer.pos, true); A_Stop(); PlrCheck.SetFlying(invoker, false);	}
				}
				else	PlrCheck.SetFlying(invoker, false);
			}
			else invoker.count++;
		}
		Wait;
	Pickup:
		TNT1 A 0
		{
			invoker.items.Clear();
			if (!CountInv("D4MegachargeUpgrade1"))	invoker.items.Push("D4MegachargeUpgrade1");
			if (!CountInv("D4MegachargeUpgrade2"))	invoker.items.Push("D4MegachargeUpgrade2");
			if (!CountInv("D4DoomDollUpgrade1"))	invoker.items.Push("D4DoomDollUpgrade1");
			if (!CountInv("D4DoomDollUpgrade2"))	invoker.items.Push("D4DoomDollUpgrade2");
			if (!CountInv("D4RegenUpgrade1"))	invoker.items.Push("D4RegenUpgrade1");
			else if (!CountInv("D4RegenUpgrade2"))	invoker.items.Push("D4RegenUpgrade2"); //Requires the first.
			if (!CountInv("D4RegenUpgrade3"))	invoker.items.Push("D4RegenUpgrade3");
			if (!CountInv("D4RegenUpgrade4"))	invoker.items.Push("D4RegenUpgrade4");
			if (!CountInv("D4PentagramUpgrade1"))	invoker.items.Push("D4PentagramUpgrade1");
			if (!CountInv("D4PentagramUpgrade2"))	invoker.items.Push("D4PentagramUpgrade2");
			if (!CountInv("D4PentagramUpgrade3"))	invoker.items.Push("D4PentagramUpgrade3");
			if (!CountInv("D4PentagramUpgrade4"))	invoker.items.Push("D4PentagramUpgrade4");
			//if (!CountInv("D4RuneUpgrade1"))	invoker.items.Push("D4RuneUpgrade1");
			if (!CountInv("D4RuneUpgrade2"))	invoker.items.Push("D4RuneUpgrade2");
			if (!CountInv("D4RuneUpgrade3"))	invoker.items.Push("D4RuneUpgrade3");
			if (!CountInv("D4RuneUpgrade4"))	invoker.items.Push("D4RuneUpgrade4");
			if (invoker.items.Size() > 0)
			{
				int rng = random(0, invoker.items.Size() - 1);
				Class<Inventory> som = invoker.items[rng];
				if (som)	A_GiveInventory(som);
				A_Print("$"..invoker.items[rng]);
			}
			
			ACS_NamedExecute("SaveTokens",0,0,0,0);
			return true;
		}
		Stop;
	}
}


/*
// Template
Class D4UpgradePickup : D4PowerUpgradePickup
{
	Default
	{
		Inventory.PickupMessage " Upgrade";
	}
	States
	{
	Pickup:
		TNT1 A 0
		{
			if (!CountInv(""))
			
			ACS_NamedExecute("SaveTokens",0,0,0,0);
			return true;
		}
		Stop;
	}
}*/

//==============================================================================
// Suit
//==============================================================================

Class D4SuitUpgradePickup : CustomInventory
{
	int ticker;
	int count;
	bool Flying;
	UpgradePinataFlier flier;
	Default
	{
		+INVENTORY.ALWAYSPICKUP
		+BRIGHT
	}
	States
	{
	Spawn:
		M670 G 17 NoDelay
		{
			invoker.flier = new("UpgradePinataFlier");
			if (invoker.flier)
			{
				invoker.flier.Spawner = invoker;
				invoker.flier.NoItem = true;
			}
		}
		M671 G 17;
		"----" A 1
		{
			invoker.ticker = (invoker.ticker + 1) % 34;
			
			Name spr = (invoker.ticker < 17) ? "M670" : "M671";
			sprite = GetSpriteIndex(spr);
				
			if (invoker.count >= DelayVacuum)
			{
				if (tracer)
				{
					invoker.count = DelayVacuum;
					PlrCheck.SetFlying(invoker, true);
					A_FaceTracer(0,0,0,0,FAF_MIDDLE);
					A_ChangeVelocity(x: cos(pitch)*PSpeed, z: -sin(pitch)*PSpeed, flags: CVF_RELATIVE|CVF_REPLACE);
					if (Distance3D(tracer) <= 32)
					{	SetOrigin(tracer.pos, true); A_Stop(); PlrCheck.SetFlying(invoker, false);	}
				}
				else	PlrCheck.SetFlying(invoker, false);
			}
			else invoker.count++;
		}
		Wait;
	Pickup:
		TNT1 A 0
		{
			// He's making a list, checking it twice!
			// Gonna find out whose a jackass or vice!
			// Satan Claws is coming to drown!
			
			Array<String> list;
			list.Clear();
			
			if (CountInv("D4AirUpgrade") < 3)			list.Push("D4AirUpgrade");
			if (CountInv("D4Stamina") < 100)			list.Push("D4Stamina");
			if (CountInv("D4ArmorCapRaiser") < 100)		list.Push("D4ArmorCapRaiser");
			if (CountInv("D4CrateUpgrade") < 3)			list.Push("D4CrateUpgrade");
			if (CountInv("ProtectionBonus") < 3)		list.Push("ProtectionBonus");
			
			if (list.Size() < 1)	
				return true;
			
			int rng = random(0, list.Size() - 1);	// Choose a random one.
			Class<Inventory> check = list[rng];		// Make sure it exists.
			
			if (check)
			{
				if (list[rng] == 'D4Stamina' || list[rng] == 'D4ArmorCapRaiser')
				{
					if (CountInv(check) >= 50)	A_SetInventory(check,100);
					else						A_GiveInventory(check, 25);
				}
				else
				{
					A_GiveInventory(check,1);
				}
				let item = UpgradeItem(FindInventory(check));
				if (item)
				{
					item.UpdateItem();
					item.PrintDesc();
				}
			}
			else Console.Printf("ERROR: %s - bad item!", list[rng]);
			return true;
		}
		Stop;
	}
}

Class D4ArmorUpgradePickup : D4SuitUpgradePickup
{
	Default
	{
		Inventory.PickupMessage "Armor Upgrade";
	}
	States
	{
	Pickup:
		TNT1 A 0
		{
			bool given = true;
			int amt = CountInv("D4ArmorCapRaiser");
				 if (amt < 25)		A_SetInventory("D4ArmorCapRaiser",25);
			else if (amt < 50)		A_SetInventory("D4ArmorCapRaiser",50);
			else if (amt < 100)		A_SetInventory("D4ArmorCapRaiser",100);
			else
			{
				given = false;
				if (A_GiveInventory("ArmorStripper",1))
					A_GiveInventory("D4BlueArmorMegasphere",1);
			}
			
			if (given)
			{
				amt = CountInv("D4ArmorCapRaiser");
				String line1 = "Armor Capacity +"..amt.."\n";
				
					 if (amt >= 100)	line1 = line1.."Chainsaw Alt guarantees minimum 2 armor shards";
				else if (amt >= 50)		line1 = line1.."Chainsaw Alt: + 0 to 4 Armor Shards";
				else					line1 = line1.."Chainsaw Alt: + 0 to 2 Armor Shards";
				
				A_Print(line1);
			}
			ACS_NamedExecute("SaveTokens",0,0,0,0);
			return true;
		}
		Stop;
	}
}

Class D4CashUpgradePickup : D4SuitUpgradePickup
{
	Default
	{
		Inventory.PickupMessage "Credit Upgrade";
	}
	States
	{
	Pickup:
		TNT1 A 0
		{
			if (CountInv("CashPercentBonus") < 40)		
			{
				A_GiveInventory("CashPercentBonus",10);
				int amt = CountInv("CashPercentBonus");
				
				A_Print("Credit Upgrade +"..amt.."%");
			}
			ACS_NamedExecute("SaveTokens",0,0,0,0);
			return true;
		}
		Stop;
	}
}

Class D4CrateUpgradePickup : D4SuitUpgradePickup
{
	Default
	{
		Inventory.PickupMessage "Crate Upgrade";
	}
	States
	{
	Pickup:
		TNT1 A 0
		{
			int amt = CountInv("D4CrateUpgrade");
			if (amt < 3)		
			{
				A_GiveInventory("D4CrateUpgrade",1);
				
				amt += 1;
					 if (amt == 1)	A_Print("Heavy Crates\nGuarantees larger quality items");
				else if (amt == 2)	A_Print("Sensor Crates\nCrates are more situationally aware");
				else				A_Print("Weapon Crates\nCrates may contain weapons");
				
			}
			ACS_NamedExecute("SaveTokens",0,0,0,0);
			return true;
		}
		Stop;
	}
}

Class D4ProtectionUpgradePickup : D4SuitUpgradePickup
{
	Default
	{
		Inventory.PickupMessage "Protection Upgrade";
	}
	States
	{
	Pickup:
		TNT1 A 0
		{
			if (!CountInv("ProtectionBonus1"))
			{
				A_SetInventory("ProtectionBonus1",1);
				A_Print("50% Environment Damage Reduction");
			}
			else if (!CountInv("ProtectionBonus2"))
			{
				A_SetInventory("ProtectionBonus2",1);
				A_Print("50% Self Damage Reduction");
			}
			else if (!CountInv("ProtectionBonus3"))
			{
				A_SetInventory("ProtectionBonus3",1);
				A_Print("50% Radius Damage Reduction");
			}
			else
			{
				A_PlaySound("PentagramOfProtection/Pickup",CHAN_ITEM,1);
				A_GiveInventory("PentagramOfProtection",1); //Fuck it, why not. :P
			}
			ACS_NamedExecute("SaveTokens",0,0,0,0);
			return true;
		}
		Stop;
	}
}

//==============================================================================
// Weapon Upgrades
//==============================================================================

Class D4UpgradePickup : CustomInventory
{
	UpgradePinataFlier flier;
	Class<Inventory> items[10];	
	String desc[5];
	uint index;
	int ticker;
	int count;
	bool Flying;
	int frm;
	name s1, s2;
	property Frame: frm;
	override void PostBeginPlay()
	{
		
		if (GetClass() == "D4UpgradePickup")
		{
			Destroy();
			return;
		}
		angle = random(0,359);
		bTHRUACTORS = false;
		Super.PostBeginPlay();
	}
	Default
	{
		+INVENTORY.ALWAYSPICKUP
		+BRIGHT
	}
	
	States
	{
	Spawn:
		"----" A 0 NoDelay
		{
			invoker.flier = new("UpgradePinataFlier");
			if (invoker.flier)
			{
				invoker.flier.Spawner = invoker;
				invoker.flier.NoItem = true;
			}
		}
		"----" A 1
		{
			invoker.ticker = (invoker.ticker + 1) % 34;
			
			name spr = (invoker.ticker < 17) ? "M668" : "M669";
			sprite = GetSpriteIndex(spr);
				
			frame = invoker.frm;
				
			if (invoker.count >= DelayVacuum)
			{
				if (tracer)
				{
					invoker.count = DelayVacuum;
					PlrCheck.SetFlying(invoker, true);
					A_FaceTracer(0,0,0,0,FAF_MIDDLE);
					A_ChangeVelocity(x: cos(pitch)*PSpeed, z: -sin(pitch)*PSpeed, flags: CVF_RELATIVE|CVF_REPLACE);
					if (Distance3D(tracer) <= 32)
					{	SetOrigin(tracer.pos, true); A_Stop(); PlrCheck.SetFlying(invoker, false);	}
				}
				else	PlrCheck.SetFlying(invoker, false);
			}
			else invoker.count++;
		}
		Wait;
	}
}


Class PistolUpgradePickup : D4UpgradePickup
{
	Default
	{
		D4UpgradePickup.Frame 1;
	}
	States
	{
	Pickup:
		TNT1 A 0
		{
			static const Class<Inventory> itemnames[] =
			{	"PistolUpgradeAutomatic",	
				"PistolUpgradeAltDamage",	
				"PistolUpgradeAltCharge",	
				"PistolUpgradeDamage",
				"PistolUpgradeLance"	};
			
			static const String itemstr[] =
			{	"$PistolUpgradeAutomatic",	
				"$PistolUpgradeAltDamage",	
				"$PistolUpgradeAltCharge",	
				"$PistolUpgradeDamage",
				"$PistolUpgradeLance"	};
			
			int count = 0;
			for (int i = 0; i < itemnames.Size(); i++)
			{
				if (itemnames[i] && !CountInv(itemnames[i]))
				{
					if (itemnames[i] == "PistolUpgradeLance" && 
						(!CountInv("PistolUpgradeAltDamage") || !CountInv("PistolUpgradeAltCharge")))
						continue;
						
					invoker.desc[invoker.index] = itemstr[i];
					invoker.items[invoker.index] = itemnames[i];
					invoker.index++;
					count++;
				}
			}
			
			if (count < 1)
				return true;
			
			invoker.index--;
			uint rng = random(0,invoker.index);
			
			if (invoker.items[rng])
			{
				A_PrintBold(invoker.desc[rng]);
				A_GiveInventory(invoker.items[rng]);
			}
			ACS_NamedExecute("SaveTokens",0,0,0,0);
			return true;
		}
		Stop;
	}
}

Class ShotgunUpgradePickup : D4UpgradePickup
{
	Default
	{
		D4UpgradePickup.Frame 2;
	}
	States
	{
	Pickup:
		TNT1 A 0
		{
			static const Class<Inventory> itemnames[] =
			{	"ShotgunMod1",	"ShotgunMod2"	};
			
			static const String itemstr[] =
			{	"$ShotgunMod1",	"$ShotgunMod2"	};
			int count = 0;
			for (int i = 0; i < itemnames.Size(); i++)
			{
				if (itemnames[i] && !CountInv(itemnames[i]))
				{
					invoker.desc[invoker.index] = itemstr[i];
					invoker.items[invoker.index] = itemnames[i];
					invoker.index++;
				count++;
				}
			}
			
			if (count < 1)
				return true;
			invoker.index--;
			int rng = random(0,invoker.index);
			
			if (invoker.items[rng])
			{
				A_PrintBold(invoker.desc[rng]);
				A_GiveInventory(invoker.items[rng]);
			}
			ACS_NamedExecute("SaveTokens",0,0,0,0);
			return true;
		}
		Stop;
	}
}

Class SuperShotgunUpgradePickup : D4UpgradePickup
{
	Default
	{
		D4UpgradePickup.Frame 3;
	}
	States
	{
	Pickup:
		TNT1 A 0
		{
			static const Class<Inventory> itemnames[] =
			{	"SSGUpgrade1",	"SSGUpgrade2",	"SSGUpgrade3",	"SSGUpgrade4"	};
			
			static const String itemstr[] =
			{	"$SSGUpgrade1",	"$SSGUpgrade2",	"$SSGUpgrade3",	"$SSGUpgrade4"	};
			int count = 0;
			for (int i = 0; i < itemnames.Size(); i++)
			{
				if (itemnames[i] && !CountInv(itemnames[i]))
				{
					if (itemnames[i] == "SSGUpgrade4" &&
						(!CountInv("SSGUpgrade1") || !CountInv("SSGUpgrade2")))
						continue;
					
					invoker.desc[invoker.index] = itemstr[i];
					invoker.items[invoker.index] = itemnames[i];
					invoker.index++;
					count++;
				}
			}	
			
			if (count < 1)
				return true;
			invoker.index--;
			int rng = random(0,invoker.index);
			
			if (invoker.items[rng])
			{
				A_PrintBold(invoker.desc[rng]);
				A_GiveInventory(invoker.items[rng]);
			}
			ACS_NamedExecute("SaveTokens",0,0,0,0);
			return true;
		}
		Stop;
	}
}

Class StaticRifleUpgradePickup : D4UpgradePickup
{
	Default
	{
		D4UpgradePickup.Frame 10;
	}
	States
	{
	Pickup:
		TNT1 A 0
		{
			// This one's entirely linear enough, so don't bother with randomizing.
			if (!CountInv("StaticUpgrade1"))
			{
				A_GiveInventory("StaticUpgrade1");
				A_PrintBold("$StaticUpgrade1");
			}
			else if (!CountInv("StaticUpgrade2"))
			{
				A_GiveInventory("StaticUpgrade2");
				A_PrintBold("$StaticUpgrade2");
			}
			else if (!CountInv("StaticUpgrade3"))
			{
				A_GiveInventory("StaticUpgrade3");
				A_PrintBold("$StaticUpgrade3");
			}
			else if (!CountInv("StaticUpgrade4"))
			{
				A_GiveInventory("StaticUpgrade4");
				A_PrintBold("$StaticUpgrade4");
			}
			ACS_NamedExecute("SaveTokens",0,0,0,0);
			return true;
		}
		Stop;
	}
}

Class RepeaterUpgradePickup : D4UpgradePickup
{
	Default
	{
		D4UpgradePickup.Frame 11;
	}
	States
	{
	Pickup:
		TNT1 A 0
		{
			static const Class<Inventory> itemnames[] =
			{ "RepeaterUpgradePiercing", "RepeaterUpgradeDamage", "RepeaterUpgradeAltDamage", "RepeaterUpgradeAltAmmo" };
			
			static const String itemstr[] =
			{ "$RepeaterUpgradePiercing", "$RepeaterUpgradeDamage", "$RepeaterUpgradeAltDamage", "$RepeaterUpgradeAltAmmo" };
			int count = 0;
			for (int i = 0; i < itemnames.Size(); i++)
			{
				if (itemnames[i] && !CountInv(itemnames[i]))
				{
					invoker.desc[invoker.index] = itemstr[i];
					invoker.items[invoker.index] = itemnames[i];
					invoker.index++;
					count++;
				}
			}
			
			if (count < 1)
				return true;
			invoker.index--;
			int rng = random(0,invoker.index);
			
			if (invoker.items[rng])
			{
				A_PrintBold(invoker.desc[rng]);
				A_GiveInventory(invoker.items[rng]);
			}
			ACS_NamedExecute("SaveTokens",0,0,0,0);
			return true;
		}
		Stop;
	}
}

Class AssaultRifleUpgradePickup : D4UpgradePickup
{
	Default
	{
		D4UpgradePickup.Frame 4;
	}
	States
	{
	Pickup:
		TNT1 A 0
		{
			static const Class<Inventory> itemnames[] =
			{	"AssaultRifleMod1",		"AssaultRifleMod2"	};
			
			static const String itemstr[] =
			{	"$AssaultRifleMod1",	"$AssaultRifleMod2"	};
			int count = 0;
			for (int i = 0; i < itemnames.Size(); i++)
			{
				if (itemnames[i] && !CountInv(itemnames[i]))
				{
					invoker.desc[invoker.index] = itemstr[i];
					invoker.items[invoker.index] = itemnames[i];
					invoker.index++;
					count++;
				}
			}
			
			if (count < 1)
				return true;
			
			invoker.index--;
			int rng = random(0,invoker.index);
			
			if (invoker.items[rng])
			{
				A_PrintBold(invoker.desc[rng]);
				A_GiveInventory(invoker.items[rng]);
			}
			ACS_NamedExecute("SaveTokens",0,0,0,0);
			return true;
		}
		Stop;
	}
}

Class ChaingunUpgradePickup : D4UpgradePickup
{
	Default
	{
		D4UpgradePickup.Frame 5;
	}
	States
	{
	Pickup:
		TNT1 A 0
		{
			static const Class<Inventory> itemnames[] =
			{	"ChaingunMod1",		"ChaingunMod2"	};
			
			static const String itemstr[] =
			{	"$ChaingunMod1",	"$ChaingunMod2"	};
			int count = 0;
			for (int i = 0; i < itemnames.Size(); i++)
			{
				if (itemnames[i] && !CountInv(itemnames[i]))
				{
					invoker.desc[invoker.index] = itemstr[i];
					invoker.items[invoker.index] = itemnames[i];
					invoker.index++;
					count++;
				}
			}
			
			if (count < 1)
				return true;
			
			invoker.index--;
			int rng = random(0,invoker.index);
			
			if (invoker.items[rng])
			{
				A_PrintBold(invoker.desc[rng]);
				A_GiveInventory(invoker.items[rng]);
			}
			ACS_NamedExecute("SaveTokens",0,0,0,0);
			return true;
		}
		Stop;
	}
}

Class RocketLauncherUpgradePickup : D4UpgradePickup
{
	Default
	{
		D4UpgradePickup.Frame 6;
	}
	States
	{
	Pickup:
		TNT1 A 0
		{
			static const Class<Inventory> itemnames[] =
			{	"RocketLauncherMod1",	"RocketLauncherMod2"	};
			
			static const String itemstr[] =
			{	"$RocketLauncherMod1",	"$RocketLauncherMod2"	};
			int count = 0;
			for (int i = 0; i < itemnames.Size(); i++)
			{
				if (itemnames[i] && !CountInv(itemnames[i]))
				{
					invoker.desc[invoker.index] = itemstr[i];
					invoker.items[invoker.index] = itemnames[i];
					invoker.index++;
					count++;
				}
			}
			
			if (count < 1)
				return true;
			invoker.index--;
			int rng = random(0,invoker.index);
			
			if (invoker.items[rng])
			{
				A_PrintBold(invoker.desc[rng]);
				A_GiveInventory(invoker.items[rng]);
			}
			ACS_NamedExecute("SaveTokens",0,0,0,0);
			return true;
		}
		Stop;
	}
}

Class PlasmaRifleUpgradePickup : D4UpgradePickup
{
	Default
	{
		D4UpgradePickup.Frame 7;
	}
	States
	{
	Pickup:
		TNT1 A 0
		{
			static const Class<Inventory> itemnames[] =
			{	"PlasmaRifleMod1",	"PlasmaRifleMod2"	};
			
			static const String itemstr[] =
			{	"$PlasmaRifleMod1",	"$PlasmaRifleMod2"	};
			int count = 0;
			for (int i = 0; i < itemnames.Size(); i++)
			{
				if (itemnames[i] && !CountInv(itemnames[i]))
				{
					invoker.desc[invoker.index] = itemstr[i];
					invoker.items[invoker.index] = itemnames[i];
					invoker.index++;
					count++;
				}
			}
			
			if (count < 1)
				return true;
			invoker.index--;
			int rng = random(0,invoker.index);
			
			if (invoker.items[rng])
			{
				A_PrintBold(invoker.desc[rng]);
				A_GiveInventory(invoker.items[rng]);
			}
			ACS_NamedExecute("SaveTokens",0,0,0,0);
			return true;
		}
		Stop;
	}
}

Class LightningGunUpgradePickup : D4UpgradePickup
{	
	Default
	{
		D4UpgradePickup.Frame 13;
	}
	States
	{
	Pickup:
		TNT1 A 0
		{
			static const Class<Inventory> itemnames[] =
			{ "LGUpgradeAmmo", "LGUpgradeRange", "LGUpgradeDamage", "LGUpgradeAltFire" };
			
			static const String itemstr[] =
			{ "$LGUpgradeAmmo", "$LGUpgradeRange", "$LGUpgradeDamage", "$LGUpgradeAltFire" };
			int count = 0;
			for (int i = 0; i < itemnames.Size(); i++)
			{
				if (itemnames[i] && !CountInv(itemnames[i]))
				{
					invoker.desc[invoker.index] = itemstr[i];
					invoker.items[invoker.index] = itemnames[i];
					invoker.index++;
					count++;
				}
			}
			
			if (count < 1)
				return true;
			invoker.index--;
			int rng = random(0,invoker.index);
			
			if (invoker.items[rng])
			{
				A_PrintBold(invoker.desc[rng]);
				A_GiveInventory(invoker.items[rng]);
			}
			ACS_NamedExecute("SaveTokens",0,0,0,0);
			return true;
		}
		Stop;
	}
}

Class VortexRifleUpgradePickup : D4UpgradePickup
{	
	Default
	{
		D4UpgradePickup.Frame 12;
	}
	States
	{
	Pickup:
		TNT1 A 0
		{
			static const Class<Inventory> itemnames[] =
			{ "VortexUpgradeDamage", "VortexUpgradeAmmo", "VortexUpgradeAltSpeed", "VortexUpgradeAltPierce" };
			
			static const String itemstr[] =
			{ "$VortexUpgradeDamage", "$VortexUpgradeAmmo", "$VortexUpgradeAltSpeed", "$VortexUpgradeAltPierce" };
			int count = 0;
			for (int i = 0; i < itemnames.Size(); i++)
			{
				if (itemnames[i] && !CountInv(itemnames[i]))
				{
					invoker.desc[invoker.index] = itemstr[i];
					invoker.items[invoker.index] = itemnames[i];
					invoker.index++;
					count++;
				}
			}
			
			if (count < 1)
				return true;
			invoker.index--;
			int rng = random(0,invoker.index);
			
			if (invoker.items[rng])
			{
				A_PrintBold(invoker.desc[rng]);
				A_GiveInventory(invoker.items[rng]);
			}
			ACS_NamedExecute("SaveTokens",0,0,0,0);
			return true;
		}
		Stop;
	}
}

Class GaussCannonUpgradePickup : D4UpgradePickup
{
	Default
	{
		D4UpgradePickup.Frame 9;
	}
	States
	{
	Pickup:
		TNT1 A 0
		{
			static const Class<Inventory> itemnames[] =
			{	"GaussCannonMod1",	"GaussCannonMod2"	};
			
			static const String itemstr[] =
			{	"$GaussCannonMod1",	"$GaussCannonMod2"	};
			int count = 0;
			for (int i = 0; i < itemnames.Size(); i++)
			{
				if (itemnames[i] && !CountInv(itemnames[i]))
				{
					invoker.desc[invoker.index] = itemstr[i];
					invoker.items[invoker.index] = itemnames[i];
					invoker.index++;
				count++;
				}
			}
			
			if (count < 1)
				return true;
			invoker.index--;
			int rng = random(0,invoker.index);
			
			if (invoker.items[rng])
			{
				A_PrintBold(invoker.desc[rng]);
				A_GiveInventory(invoker.items[rng]);
			}
			ACS_NamedExecute("SaveTokens",0,0,0,0);
			return true;
		}
		Stop;
	}
}

Class BFGUpgradePickup : D4UpgradePickup
{
	Default
	{
		D4UpgradePickup.Frame 8;
	}
	States
	{
	Pickup:
		TNT1 A 0
		{
			static const Class<Inventory> itemnames[] =
			{ "BFGUpgrade1", "BFGUpgrade2", "BFGUpgrade3", "BFGUpgrade4" };
			
			static const String itemstr[] =
			{ "$BFGUpgrade1", "$BFGUpgrade2", "$BFGUpgrade3", "$BFGUpgrade4" };
			int count = 0;
			for (int i = 0; i < itemnames.Size(); i++)
			{
				if (itemnames[i] && !CountInv(itemnames[i]))
				{
					invoker.desc[invoker.index] = itemstr[i];
					invoker.items[invoker.index] = itemnames[i];
					invoker.index++;
					count++;
				}
			}
			
			if (count < 1)
				return true;
			invoker.index--;
			int rng = random(0,invoker.index);
			
			if (invoker.items[rng])
			{
				A_PrintBold(invoker.desc[rng]);
				A_GiveInventory(invoker.items[rng]);
			}
			ACS_NamedExecute("SaveTokens",0,0,0,0);
			return true;
		}
		Stop;
	}
}

Class CarrionCannonUpgradePickup : D4UpgradePickup
{
	Default
	{
		D4UpgradePickup.Frame 14;
	}
	States
	{
	Pickup:
		TNT1 A 0
		{
			static const Class<Inventory> itemnames[] =
			{ "CarrionUpgradePickup", "CarrionUpgradeAmmo", "CarrionUpgradeStun", "CarrionUpgradeTime" };
			
			static const String itemstr[] =
			{ "$CarrionUpgradePickup", "$CarrionUpgradeAmmo", "$CarrionUpgradeStun", "$CarrionUpgradeTime" };
			int count = 0;
			for (int i = 0; i < itemnames.Size(); i++)
			{
				if (itemnames[i] && !CountInv(itemnames[i]))
				{
					invoker.desc[invoker.index] = itemstr[i];
					invoker.items[invoker.index] = itemnames[i];
					invoker.index++;
					count++;
				}
			}
			
			if (count < 1)
				return true;
			invoker.index--;
			int rng = random(0,invoker.index);
			
			if (invoker.items[rng])
			{
				A_PrintBold(invoker.desc[rng]);
				A_GiveInventory(invoker.items[rng]);
			}
			ACS_NamedExecute("SaveTokens",0,0,0,0);
			return true;
		}
		Stop;
	}
}

Class SovietChaingunUpgradePickup : D4UpgradePickup
{
	Default
	{
		D4UpgradePickup.Frame 25;
		+INVENTORY.ALWAYSPICKUP
		+BRIGHT
		Inventory.PickupSound "Doom4/Other/WeaponPickup";
		Inventory.PickupMessage "For Mother Russia!";
		Translation "0:255=%[0.0,0.0,0.0]:[1.0,0.75,0.0]";
	}
	States
	{
	Pickup:
		TNT1 A 0
		{
			if (!CountInv("SovietToken"))
			{	
				//A_SpawnItemEx("HolyShitScreamer",flags:SXF_NOCHECKPOSITION);
				A_SetInventory("SovietToken",1);
				A_SetInventory("SovietActive",1);
			}
			// BUGS THIS BIG BECOME FEATURES!
			A_SetInventory("D4Bullets",CountInv("D4Bullets") + 666,DefPtr,true);
		}
		Stop;
	}
}

Class HolyShitScreamer : Actor
{
	Default
	{
		+NOINTERACTION +NOBLOCKMAP +THRUACTORS +NOTONAUTOMAP
		RenderStyle "None";
	}
	States
	{
	Spawn:
		TNT1 A 35 NoDelay A_PlaySound("HOLYSHIT",CHAN_VOICE,1,0,ATTN_NONE);
		Stop;
	}
}

/*
//Chainsaw
M668A = "M668A" {Spin=50}
M669A = "M669A" {Spin=50}
WPPKA = "WPPKA" {Spin=50}

//Pistol
M668B = "M668B" {Spin=50}
M669B = "M669B" {Spin=50}
WPPKB = "WPPKB" {Spin=50}

//Shotgun
M668C = "M668C" {Spin=50}
M669C = "M669C" {Spin=50}
WPPKC = "WPPKC" {Spin=50}

//Super Shotgun
M668D = "M668D" {Spin=50}
M669D = "M669D" {Spin=50}
WPPKD = "WPPKD" {Spin=50}

//Heavy Assault Rifle
M668E = "M668E" {Spin=50}
M669E = "M669E" {Spin=50}
WPPKE = "WPPKE" {Spin=50}

//Chaingun
M668F = "M668F" {Spin=50}
M669F = "M669F" {Spin=50}
WPPKF = "WPPKF" {Spin=50}

//Rocket Launcher
M668G = "M668G" {Spin=50}
M669G = "M669G" {Spin=50}
WPPKG = "WPPKG" {Spin=50}

//Plasma Rifle
M668H = "M668H" {Spin=50}
M669H = "M669H" {Spin=50}
WPPKH = "WPPKH" {Spin=50}

//BFG 9000
M668I = "M668I" {Spin=50}
M669I = "M669I" {Spin=50}
WPPKI = "WPPKI" {Spin=50}

//Gauss Cannon
M668J = "M668J" {Spin=50}
M669J = "M669J" {Spin=50}
WPPKJ = "WPPKJ" {Spin=50}

//Static rifle
M668K = "Voxels/staticNOTSELECTED.kvx" {scale=0.7 Spin=50}
M669K = "Voxels/staticSELECTED.kvx" {scale=0.7 Spin=50}
WPPKK = "WPPKK" {Spin=50}

//Repeater
M668L = "Voxels/repeaterNOTSELECTED.kvx" {scale=0.85 Spin=50}
M669L = "Voxels/repeaterSELECTED.kvx" {scale=0.85 Spin=50}
WPPKL = "Voxels/PickupRepeater.kvx" {Spin=50}

//Vortex Rifle
M668M = "Voxels/vortexNOTSELECTED.kvx" {scale=0.7 Spin=50}
M669M = "Voxels/vortexSELECTED.kvx" {scale=0.7 Spin=50}
WPPKM = "Voxels/PickupVortex.kvx" {Spin=50}

//Lightning Gun 
M668N = "Voxels/lgunNOTSELECTED.kvx" {scale=0.7 Spin=50}
M669N = "Voxels/lgunSELECTED.kvx" {scale=0.7 Spin=50}
WPPKN = "WPPKN" {Spin=50}

//Carrion Cannon
M668O = "Voxels/hellNOTSELECTED.kvx" {scale=0.7 Spin=50}
M669O = "Voxels/hellSELECTED.kvx" {scale=0.7 Spin=50}
WPPKO = "Voxels/PickupHellshot.kvx" {scale=0.7 Spin=50}
*/